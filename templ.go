package main

import (
	"fmt"
	"io"
	"log"
	"strings"
	"text/template"
)

var (
	types map[string]struct{}

	// Struct field generated from an element attribute
	attr = "{{ define \"Attr\" }}{{ printf \"  %s \" (lintTitle .Name) }}{{ printf \"%s `xml:\\\"%s,attr\\\"`\" (lint .Type) .Name }}\n{{ end }}"

	// Struct field generated from an element child element
	child = "{{ define \"Child\" }}{{ printf \"  %s \" (lintTitle .Name) }}{{ if .List }}[]{{ end }}{{ printf \"%s `xml:\\\"%s\\\"`\" (typeName .FieldType) .Name }}\n{{ end }}"

	// Struct field generated from an element with attributes
	cdata = "{{ define \"Cdata\" }}{{ printf \"%s %s `xml:\\\",chardata\\\"`\\n\" (lintTitle .Name) (lint .Type) }}{{ end }}"

	// Struct generated from a non-trivial element (with children and/or attributes)
	elem = `{{ define "Elem" }}{{ printf "// %s is generated from an XSD element\ntype %s struct {\n" (typeName .Name) (typeName .Name) }}{{ range $a := .Attribs }}{{ template "Attr" $a }}{{ end }}{{ range $c := .Children }}{{ template "Child" $c }}{{ end }} {{ if .Cdata }}{{ template "Cdata" . }}{{ end }} }
	{{ end }}`

	templ = `{{ template "Elem" . }}
`

	fmap = template.FuncMap{
		"lint":      lint,
		"lintTitle": lintTitle,
		"typeName":  typeName,
	}

	tt *template.Template

	// The initialism pairs are based on the commonInitialisms found in golang/lint
	// https://github.com/golang/lint/blob/4946cea8b6efd778dc31dc2dbeb919535e1b7529/lint.go#L698-L738
	//
	initialismPairs = []string{
		"Api", "API",
		"Ascii", "ASCII",
		"Cpu", "CPU",
		"Css", "CSS",
		"Dns", "DNS",
		"Eof", "EOF",
		"Guid", "GUID",
		"Html", "HTML",
		"Https", "HTTPS",
		"Http", "HTTP",
		"Id", "ID",
		"Ip", "IP",
		"Json", "JSON",
		"Lhs", "LHS",
		"Qps", "QPS",
		"Ram", "RAM",
		"Rhs", "RHS",
		"Rpc", "RPC",
		"Sla", "SLA",
		"Smtp", "SMTP",
		"Sql", "SQL",
		"Ssh", "SSH",
		"Tcp", "TCP",
		"Tls", "TLS",
		"Ttl", "TTL",
		"Udp", "UDP",
		"Uid", "UID",
		"Ui", "UI",
		"Uuid", "UUID",
		"Uri", "URI",
		"Url", "URL",
		"Utf8", "UTF8",
		"Vm", "VM",
		"Xml", "XML",
		"Xsrf", "XSRF",
		"Xss", "XSS",
	}

	initialisms = strings.NewReplacer(initialismPairs...)
)

func init() {
	types = make(map[string]struct{})

	tt = template.New("yyy").Funcs(fmap)
	tt.Parse(attr)
	tt.Parse(cdata)
	tt.Parse(child)
	tt.Parse(elem)
	tt.Parse(templ)

}

func generateGo(out io.Writer, roots []*xmlElem) {
	if pckg != "" {
		fmt.Fprintf(out, "// generated by goxsd; DO NOT EDIT\n\npackage %s\n\n", pckg)
	}

	for _, e := range roots {
		doGenerate(e, out)
	}
}

func doGenerate(root *xmlElem, out io.Writer) {
	if _, ok := types[root.Name]; ok {
		return
	}
	if err := tt.Execute(out, root); err != nil {
		log.Fatal(err)
	}
	types[root.Name] = struct{}{}

	for _, e := range root.Children {
		if !primitive(e) {
			doGenerate(e, out)
		}
	}
}

func primitive(e *xmlElem) bool {
	if e.Cdata {
		return false
	}

	switch e.Type {
	case "bool", "string", "int", "float64", "time.Time":
		return true
	}
	return false
}

func lint(s string) string {
	return dashToCamel(squish(initialisms.Replace(s)))
}

func lintTitle(s string) string {
	return lint(strings.Title(s))
}

func typeName(s string) string {
	name := lint(s)
	switch s {
	case "bool", "string", "int", "float64", "time.Time":
	default:
		if prefix != "" {
			name = prefix + strings.Title(name)
		}
		if exported {
			name = strings.Title(name)
		}
	}
	return name
}

func squish(s string) string {
	return strings.Replace(s, " ", "", -1)
}

func dashToCamel(name string) string {
	s := strings.Split(name, "-")
	if len(s) > 1 {
		for i := 1; i < len(s); i++ {
			s[i] = strings.Title(s[i])
		}
		return strings.Join(s, "")
	}
	return name
}
